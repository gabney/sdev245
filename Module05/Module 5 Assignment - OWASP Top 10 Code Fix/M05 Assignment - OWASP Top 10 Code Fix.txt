"""
Module 5: Assignment - OWASP Top 10 Code Fix
SDEV 245
Gabriel Abney

This file includes my code from the Module 05 assignment \
including the original vulnerable code in comments and my \
proposed corrected code below.  The README file in the \
GitHub folder containing this file includes the problem \
that I identified for each code snippet as well as how my \
proposed solution corrects those problems.

This is a .txt file becaused multiple programming languages are \
included in the code snippets.
"""



"""
1. Broken Access Control

app.get('/profile/:userId', (req, res) => {
    User.findById(req.params.userId, (err, user) => {
        if (err) return res.status(500).send(err);
        res.json(user);
    });
});
"""

# 1. My proposed solution:

app.get('/profile/:userId', (req, res) => {
    User.findById(req.params.userId, (err, user) => {
        if (err) return res.status(500).send(err);
        else res.json(user);  # moved into else statement instead of always passing the user .json data back 
    });
});




"""
2. Broken Access Control

@app.route('/account/<user_id>')
def get_account(user_id):
    user = db.query(User).filter_by(id=user_id).first()
    return jsonify(user.to_dict())
"""

# 2. My Proposed solution:

@app.route('/account/<user_id>')
def check_permissions(user_id, account_token) # gets the token about who is logged in for the request
    if user_id == account_token:
        return True # logged in account is same as requested user id
    else:
        return False # different account login from requested user id
def get_account(user_id):
    if check_permission() == True:
        user = db.query(User).filter_by(id=user_id).first()
        return jsonify(user.to_dict())
    else return error_message_permissions




"""
3. Cryptographic Failures

public String hashPassword(String password) throws NoSuchAlgorithmException {
    MessageDigest md = MessageDigest.getInstance("MD5");
    md.update(password.getBytes());
    byte[] digest = md.digest();
    return DatatypeConverter.printHexBinary(digest);
}
"""

# 3. My proposed solution
public String hashPassword(String password) throws NoSuchAlgorithmException {
    MessageDigest md = MessageDigest.getInstance("AES"); # uses AES encryption algorithm
    md.update(password.getBytes());
    byte[] digest = md.digest();
    return digest; # returns byte array without conversion




"""
4. Cryptographic Failures

import hashlib

def hash_password(password):
    return hashlib.sha1(password.encode()).hexdigest()
"""

# 4. My proposed solution

import hashlib

def hash_password(password):
    return hashlib.AES(password.encode()).hexdigest() # using AES encryption




"""
5. Injection

String username = request.getParameter("username");
String query = "SELECT * FROM users WHERE username = '" + username + "'";
Statement stmt = connection.createStatement();
ResultSet rs = stmt.executeQuery(query);
"""

# 5. My proposed solution

String username = request.getParameter("username");
String safeParams = "SELECT * FROM users WHERE username ="
safeQuery = statementPreparer.create(safeParams, username) # creates a prepared statement to compile before executing, preparing to only accept one unknown parameter
PreparedStatement stmt = connection.createPreparedStatement();
ResultSet rs = stmt.executeQuery(safeQuery);




"""
6. Injection

app.get('/user', (req, res) => {
    // Directly trusting query parameters can lead to NoSQL injection
    db.collection('users').findOne({ username: req.query.username }, (err, user) => {
        if (err) throw err;
        res.json(user);
    });
});
"""

# 6. My proposed solution

app.get('/user', (req, res) => {
    // Directly trusting query parameters can lead to NoSQL injection
    db.collection('users').findOne({ username: req.query.username }, (err, user) => {
        if (err) throw err;
        res.json(user);
    });
});